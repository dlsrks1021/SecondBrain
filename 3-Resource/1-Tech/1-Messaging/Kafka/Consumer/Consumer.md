
카프카 컨슈머는 토픽에 저장된 레코드를 읽어오는 클라이언트이며,
카프카를 **단순 메시지 큐가 아닌 로그 기반 스트리밍 시스템**으로 동작하게 만든다.

컨슈머는 다음 질문들에 대한 답을 구조적으로 포함한다.

- 누가 어떤 메시지를 읽는가?
- 어디까지 읽었는가?
- 장애가 나면 어떻게 복구되는가?
- 확장은 어떻게 이루어지는가?

---

## 컨슈머의 기본 실행 흐름

카프카 컨슈머 애플리케이션은 일반적으로 다음 순서로 동작한다.

1. KafkaConsumer 인스턴스 생성
2. 토픽 구독
3. poll() 호출을 통한 레코드 수신
4. 레코드 처리
5. 오프셋 커밋

---

## 스레드 안정성

컨슈머는 **Thread-safe 하지 않다**.

- 하나의 컨슈머 인스턴스는
  하나의 스레드에서만 사용
- 동일 그룹에서 병렬 처리는
  스레드별 컨슈머로 구성

---

## Consumer Group

카프카에서 컨슈머는 거의 항상 **컨슈머 그룹의 일부**로 동작한다.

컨슈머 그룹을 통해 카프카는:
- 파티션 단위 병렬 처리
- 컨슈머 장애 시 자동 복구
- 수평 확장(scale-out)

을 제공한다.

→ Consumer Group의 구조와 동작 원리: [[ConsumerGroup]]

---

## 폴링 루프

서버에 추가 데이터가 들어왔는지 폴링하는 단순한 루프로
무한 루프이기에 종료되지 않는다.

poll() 호출은 동시에 다음을 수행한다.

- 브로커로부터 데이터 Fetch
- 그룹 코디네이터에게 하트비트 전송
- 컨슈머 그룹 멤버십 유지
- 필요 시 리밸런스 처리

poll()이 일정 시간 이상 호출되지 않으면
컨슈머는 **죽은 것으로 간주**되어 그룹에서 제거된다.

→ 관련 설정과 제약: [[Configuration]]

---

## 오프셋과 처리 보장

컨슈머는 “메시지를 읽었다”가 아니라
“어디까지 처리했는가”를 오프셋으로 관리한다.

Offset Commit 전략에 따라:
- 메시지 중복
- 메시지 유실
- 전달 보장 수준

이 결정된다.

→ Offset과 Commit 전략: [[Offset Commit]]

---

## 리밸런스와 장애 대응

컨슈머 추가·종료·장애는
컨슈머 그룹 내부에서 **리밸런스**를 발생시킨다.

리밸런스는 단순 재할당이 아니라,
- 처리 중단
- Offset Commit 타이밍
- 시스템 지연

에 직접적인 영향을 준다.

→ Rebalance 구조와 전략: [[Rebalance]]

---

## 설정과 실행 모델

컨슈머의 성능과 안정성은
설정값과 스레드 모델에 의해 크게 좌우된다.

- fetch 전략
- poll 주기
- heartbeat 타이밍
- partition 할당 전략
- 스레드 안정성 제약

→ 설정 전체 정리: [[Configuration]]

---

## 데이터 역직렬화

컨슈머는 브로커로부터 받은 바이트 배열을
Deserializer를 통해 객체로 변환한다.

프로듀서와의 데이터 계약이 이 지점에서 연결된다.

→ Deserializer와 메시지 포맷: [[Deserializer]]
